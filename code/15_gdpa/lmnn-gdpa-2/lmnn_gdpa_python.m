function [fullM, delta, num_LP_rowcol, num_LP_full] = lmnn_gdpa_python(swap_path, idstr,gamma, beta)
% set up for the script
close all; clc;
if exist('data_feature', 'var') == 1
	clear data_feature;
end
if exist('data_label', 'var') == 1
	clear data_label;
end
if exist('data_edge', 'var') == 1
	clear data_edge;
end
% add the path to Cheng's prepared functions
addpath('SGML_LMNN')

%% load the data from disc
% tic
load([swap_path,'data_',idstr,'.mat'],'data_feature','data_label','data_edge');
data_feature = cast(data_feature, 'double');
data_label = data_label.';
[n_sample,n_feature] = size(data_feature);
data_edge = data_edge + 1;

%% set parameters
gamma = cast(gamma, 'double');
beta = cast(beta, 'double');

%=main parameters for SGML=================================================
C=n_feature; % constraint of the trace of M
rho=1e-5; % tolerance to make sure M is positive definite during optimization
lobpcg_random_control=0; % random seed for computing the first eigenvector for the first time using LOBPCG
options = optimoptions('linprog','Display','none','Algorithm','interior-point'); % linear program (LP) setting for Frank-Wolfe algorithm
options.OptimalityTolerance = 1e-2; % LP optimality tolerance
options.ConstraintTolerance = 1e-4; % LP interior-point constraint tolerance
FW_dia_offdia_tol=1e-3; % Frank-Wolfe tolerance when optimizing the diagonals + one row/column of off-diagonals
FW_full_tol=1e-5; % Frank-Wolfe tolerance when optimizing the full metric matrix M
max_iter=1e3; % maximum number of iterations for each round of Frank-Wolfe optimization
%==========================================================================

%=parameters for Frank-Wolfe step size optimization========================
GS_or_NR=2; % Frank-Wolfe step size optimization using 1) golden section search or 2) Newton-Raphson method
tol_golden_search=5e-1; % tolerance of golden section search
tol_NR=5e-1; % Newton-Raphson tolerance
tol_GD=5e-1; % gradient descent bisection tolerance
%==========================================================================

%=other parameters=========================================================
nv_od=2*n_feature-1; % number of LP variables when optimizing the diagonals + one row/column of off-diagonals
nv_full=n_feature+(n_feature*(n_feature-1))/2; % number of LP variables when optimizing the full metric matrix M
zz=logical(tril(ones(n_feature),-1)); % indices of the lower triangular part of M
dia_idx=(1:n_feature+1:n_feature^2)'; % indices of the diagonals of M
num_list=1:n_feature; % indices of graph nodes of M where the nodes are currently connected
league_vec = ones(n_feature,1); % color set of graph nodes of M
league_vec(2:2:end)=-1; % set it like this so that the odd nodes are blue and even nodes are red
bins=ones(1,n_feature); % the number of the unique numbers of bins represents the number of subgraphs of M
%==========================================================================
% tEnd = toc;
% disp(['set parameters: ', num2str(tEnd)]);

% tic
% find number of delta optimization variables
[n_delta,delta_idx] = get_delta_variables(data_label, n_sample, data_edge);
% tEnd = toc;
% disp(['find delta variables: ', num2str(tEnd)]);

% tic
%% initialize
%=Initialize M=============================================================
M0=initial_M(n_feature,2); % initial M as a [1-dense matrix] or [2-sparse matrix]
delta0=Inf*ones([n_delta,1]);

% [M0,league_vec] = determine_initial_M_appropriate_colors(data_cov,...
%     n_feature,...
%     [],...
%     [],...
%     [],...
%     2);

rng(lobpcg_random_control);
[fv1,~] = ...
    lobpcg_fv(randn(n_feature,1),M0,1e-12,200); % compute the first eigenvector for the first time using LOBPCG
save([swap_path,'M0andfv1_', idstr,'.mat'], "fv1","M0");
scaled_M = (1./fv1) .* M0 .* fv1'; % compute the similarity-transformed M
scaled_factors = (1./fv1) .* ones(n_feature) .* fv1'; % get the scalars of M
%==========================================================================
% tEnd = toc;
% disp(['initialize M and delta: ', num2str(tEnd)]);

% tic
[LP_A_sparse_i,...
    LP_A_sparse_j,...
    LP_A_sparse_s,...
    LP_b,...
    LP_lb,...
    LP_ub] = LP_setting(n_feature,n_delta,rho,data_feature,delta_idx); % get parts of the linear constraints ready for running Matlab linprog
% tEnd = toc;
% disp(['LP_setting: ', num2str(tEnd)]);

% tStart = tic
%% =run SGML=================================================================
fprintf('starting SGML.\n');
[M,delta,num_LP_rowcol,num_LP_full]=SGML_main_yasaman(M0,...
    delta0,...
    data_feature,...
    data_label,...
    data_edge,...
    n_sample,...
    n_feature,...
    n_delta,...
    delta_idx,...
    tol_NR,...
    tol_GD,...
    rho,...
    max_iter,...
    GS_or_NR,...
    tol_golden_search,...
    options,...
    FW_dia_offdia_tol,...
    FW_full_tol,...
    C,...
    gamma,...
    beta,...
    nv_od,...
    nv_full,...
    zz,...
    dia_idx,...
    num_list,...
    league_vec,...
    bins,...
    fv1,...
    scaled_M,...
    scaled_factors,...
    LP_A_sparse_i,...
    LP_A_sparse_j,...
    LP_A_sparse_s,...
    LP_b,...
    LP_lb,...
    LP_ub); % run SGML
fprintf('done with SGML.\n');
%==========================================================================
% tEnd = toc(tStart);
% disp(['SGML_main: ', num2str(tEnd)]);

%% save optimized metric matrix
fullM = full(M);
save([swap_path,'metric_delta_',idstr,'.mat'], 'fullM', 'delta')

end

